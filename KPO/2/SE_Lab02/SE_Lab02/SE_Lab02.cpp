#include <Windows.h>
#include <iostream>
using namespace std;

int add(int a, int b) {
	return a + b;
}
int main() {
	//SetConsoleOutputCP(1251);
	const int n = 2;
	const int X = 9 + n, Y = 10 + n, Z = 11 + n;
	const float S = 1.0 + n;

	//Объявите 2 переменные типа bool и инициализируйте значениями false и
	//	true.В режиме отладки определите адреса памяти, в которых расположены
	//	значения этих переменных.Продемонстрируйте содержимое памяти.
	bool varFalse = false; //  00, один байт
	bool varTrue = true; // 01

	//Объявите переменную типа char и инициализируйте ее символом
	//	латинского алфавита(второй символ вашей фамилии на английском
	//		языке).С помощью отладчика определите адрес памяти, в которой
	//	расположено значение этой переменной.Продемонстрируйте содержимое
	//	памяти, назовите кодировку.
	char surname2ndChar = 'o'; // 6f

	//Объявите переменную типа char и инициализируйте ее символом русского
	//	алфавита(второй символ вашей фамилии на русском языке).С помощью
	//	отладчика определите адрес памяти, в которой расположено значение этой
	//	переменной.Продемонстрируйте содержимое памяти, назовите кодировку.
	char sho = 'о'; // ee

	//Объявите переменную типа wchar_t и инициализируйте ее символом
	//	латинского алфавита(первый символ вашей фамилии на английском
	//		языке).С помощью отладчика определите адрес памяти, в которой
	//	расположено значение этой переменной.Продемонстрируйте содержимое
	//	памяти, назовите кодировку.
	wchar_t ideiKonchilis = L'o'; // 6f 00

	//Объявите переменную типа wchar_t и инициализируйте ее символом
	//	русского алфавита(первый символ вашей фамилии на русском языке).С
	//	помощью отладчика определите адрес памяти, в которой расположено
	//	значение этой переменной.Продемонстрируйте содержимое памяти,
	//	назовите кодировку
	wchar_t loveIs = L'о'; // ee 04

	//Объявите две переменные типа short.Инициализируйте их значениями
	//	X и –X.
	//	a.ручным способом вычислите шестнадцатеричные значения X и –X.
	//	2
	//	b.с помощью отладчика определите адрес памяти, в которой
	//	расположены значения этих переменных.Продемонстрируйте
	//	содержимое памяти.Сравните результаты.
	short x1 = X; // B vs 0b 00
	short x2 = -X; // fff5 vs f5 ff

	//. Запишите шестнадцатеричное значение самого большого числа типа short.
	//	Запишите шестнадцатеричное значение самого малого числа типа short.
	//	Присвойте эти значения двум переменным типа short и с помощью
	//	отладчика определите соответствующие десятичные значения
	// максимальное - 0x7FFF = 32767, минимальное - 0x8000 = -32768
	short maxShort = 0x7FFF; //ff 7f
	short minShort = 0x8000; //00 80

	//Запишите шестнадцатеричное значение самого большого числа типа
	//	unsigned short(определите вручную).Запишите шестнадцатеричное
	//	значение самого малого числа типа unsigned short(определите вручную).
	//	Присвойте эти значения переменным типа unsigned short и с помощью
	//	отладчика определите соответствующие десятичные значения
	//максимальное FFFF, минимальное 0
	unsigned short maxUShort = 0xFFFF; //65535
	unsigned short minUShort = 0x0000; //0

	/*Объявите две переменные типа int.Инициализируйте их значениями
		Y и –Y.Ручным способом вычислите шестнадцатеричные значения
		Y и –Y.С помощью отладчика определите адрес памяти, в которой
		расположено значение этой переменной.Продемонстрируйте содержимое
		памяти и сравните с результатом, полученным вручную*/
		// Y = 0xC, -Y = f4ffffff
	int y1 = Y; //0c 00 00 00
	int y2 = -Y; //  f4 ff ff ff

	//. Запишите шестнадцатеричное значение самого большого числа типа int.
	//	Запишите шестнадцатеричное значение самого малого числа типа int.
	//	Присвойте эти значения переменным типа int и с помощью отладчика
	//	определите соответствующие десятичные значения.
	int maxInt = 0x7FFFFFFF; //2147483647
	int minInt = 0x80000000; //-2147483648

	// Запишите шестнадцатеричное значение самого большого числа типа unsigned int.
	// Запишите шестнадцатеричное значение самого малого числа типа unsigned int.
	// Присвойте эти значения переменным типа unsigned int
	// и с помощью отладчика определите соответствующие десятичные значения.

	unsigned int maxUnsignedInt = 0xFFFFFFFFU;  // 4294967295
	unsigned int minUnsignedInt = 0x00000000U;  // 0

	//Объявите две переменные типа long.Инициализируйте их значениями Z и
	//	–Z.Ручным способом вычислите шестнадцатеричные значения Z и –Z.С
	//	помощью отладчика определите адрес памяти, в которой расположено
	//	значение этой переменной.Продемонстрируйте содержимое памяти.
	// 13 = D, -13 = FFFFFFF3(BE)
	long z1 = Z;
	long z2 = -Z;
	// Запишите шестнадцатеричное значение самого большого числа типа long.
// Запишите шестнадцатеричное значение самого малого числа типа long.
// Присвойте эти значения переменным типа long
// и с помощью отладчика определите соответствующие десятичные значения.

	long maxLong = 0x7FFFFFFFFFFFFFFF;  // 9223372036854775807
	long minLong = 0x8000000000000000;  // -9223372036854775808

	// Запишите шестнадцатеричное значение самого большого числа типа unsigned long.
// Запишите шестнадцатеричное значение самого малого числа типа unsigned long.
// Присвойте эти значения переменным типа unsigned long
// и с помощью отладчика определите соответствующие десятичные значения.

	const unsigned long maxUnsignedLong = 0xFFFFFFFFFFFFFFFFUL;  // 18446744073709551615
	const unsigned long minUnsignedLong = 0x0000000000000000UL;  // 0

	//Объявите две переменные типа float.Инициализируйте их значениями
	//	S и –S.Ручным способом вычислите шестнадцатеричные значения S и –S
	//	(с точностью до трех знаков после точки).С помощью отладчика
	//	определите адрес памяти, в которой расположено значение этой
	//	переменной.Продемонстрируйте содержимое памяти и сравните с
	//	результатом, полученным вручную.
	//4.0 = 40800000, -4.0 = C0800000
	float s1 = S; //00 00 40 40
	float s2 = -S; //00 00 40 c0

	//Выполните операции, результатами которых будут значения : 1.#INF, -
	//	1.#INF, -1.#IND.
	float zero = 0.0;
	float result1 = 1.0 / zero;
	float result2 = -1.0 / zero;
	float result3 = 0.0 / zero;

	//Объявите и проинициализируйте указатели на типы char, wchar_t, short,
	//	int, float и double.Просмотрите значения этих переменных с помощью
	//	отладчика и выпишите шестнадцатеричные представления значений.
	//	Увеличьте значения указателей на 3. Снова просмотрите эти значения,
	//	объясните полученный результат.
	char* ptrChar = &sho;
	wchar_t* ptrWchar = &loveIs;
	short* ptrShort = &x1;
	int* ptrInt = &y1;
	float* ptrFloat = &zero;
	ptrChar += 3;
	ptrWchar += 3;
	ptrShort += 3;
	ptrInt += 3;
	ptrFloat += 3;
	//cout << sizeof(ptrChar) << "  " << sizeof(ptrInt) << "  " << sizeof(ptrFloat);
	//Объявите и продемонстрируйте применение указателей на функции.
	//	Определите с помощью отладчика значения указателей.Дизассемблируйте
	//	код программы, определите, что находится в памяти по адресу равному
	//	значению этих указателей.
	int (*ptrAdd)(int, int) = add; //60 14 a8 00 (		ptrAdd	0x00b81460 {SE_Lab02.exe!add(int,int)}	int(*)(int, int)) 
	// 0x00b81460 - адрес в памяти, где расположена функция add
	/*
	//Объявите и продемонстрируйте применение указателей на функции.
	//	Определите с помощью отладчика значения указателей.Дизассемблируйте
	//	код программы, определите, что находится в памяти по адресу равному
	//	значению этих указателей.
	int (*ptrAdd)(int, int) = add; //60 14 a8 00 (		ptrAdd	0x00b81460 {SE_Lab02.exe!add(int,int)}	int(*)(int, int))
00B81B5B  mov         dword ptr [ptrAdd],offset add (0B81460h)

	return 0;
00B81B65  xor         eax,eax
}
00B81B67  push        edx
00B81B68  mov         ecx,ebp
00B81B6A  push        eax
00B81B6B  lea         edx,ds:[0B81B98h]
00B81B71  call        @_RTC_CheckStackVars@8 (0B81230h)
00B81B76  pop         eax
00B81B77  pop         edx
00B81B78  pop         edi
00B81B79  pop         esi
00B81B7A  pop         ebx
00B81B7B  mov         ecx,dword ptr [ebp-4]
00B81B7E  xor         ecx,ebp
00B81B80  call        @__security_check_cookie@4 (0B81181h)
00B81B85  add         esp,2B0h
00B81B8B  cmp         ebp,esp
00B81B8D  call        __RTC_CheckEsp (0B812A3h)
00B81B92  mov         esp,ebp
00B81B94  pop         ebp
00B81B95  ret
00B81B96  nop
00B81B98  add         eax,0A0000000h
00B81B9D  sbb         edi,dword ptr [eax-6900h]
00B81BA3  inc         dword ptr [ecx]
00B81BA5  add         byte ptr [eax],al
00B81BA7  add         dh,ch
00B81BA9  sbb         edi,dword ptr [eax-8400h]
00B81BAF  inc         dword ptr [edx]
00B81BB1  add         byte ptr [eax],al
00B81BB3  add         bh,ah
00B81BB5  sbb         edi,dword ptr [eax-9000h]
00B81BBB  inc         dword ptr [edx]
00B81BBD  add         byte ptr [eax],al
00B81BBF  add         ah,ah
00B81BC1  sbb         edi,dword ptr [eax-0D800h]
00B81BC7  inc         dword ptr [eax+eax]
00B81BCA  add         byte ptr [eax],al
00B81BCC  loope       __$EncStackInitStart+2DDh (0B81BE9h)
00B81BCE  mov         eax,0FFFE8000h
00B81BD3  inc         dword ptr [eax+eax]
00B81BD6  add         byte ptr [eax],al
00B81BD8  fcomp       qword ptr [ebx]
00B81BDA  mov         eax,72657A00h
00B81BDF  outs        dx,dword ptr [esi]
00B81BE0  add         byte ptr [ecx+31h],bh
00B81BE3  add         byte ptr [eax+31h],bh
00B81BE6  add         byte ptr [edi+ebp*2+76h],ch
00B81BEA  dec         ecx
00B81BEC  jae         __$EncStackInitStart+2E2h (0B81BEEh)
00B81BEE  jae         _main+358h (0B81C58h)
00B81BF0  outs        dx,dword ptr [esi]
00B81BF1  add         ah,cl  */

	return 0;
}
